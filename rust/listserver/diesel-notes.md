
## Getting Started Experience with Rust diesel

### The Basic Model

There are three user-provided artifacts for each table to be supported
by diesel:

- The database table itself - named in the plural, e.g., lists.

- A *model* struct that parallels the structure of the table
  and is used for *querying the table only*. This model struct is named in 
  the singular of the table name, e.g., List. The singular/plural convention 
  is assumed in diesel's code generation mechanisms.

- A *model* struct that represents those fields of the table that are to be
  explicitly provided in insert statements (missing fields would always be
  auto-generated in the database). This model struct has an arbitrary name,
  and for it, the corresponding table name must be explicitly provided.

In addition, diesel generates a low-level struct, called a *schema table* that
represents the SQL data types for the fields of each table. The source for these
goes into a schema.rs file. The location of the schema.rs file is specified in
the diesel configuration file "diesel.toml" at the root of the project.

Based on the above artifact, diesel also generate a number of convenience
symbols, structs, etc., that you can use in your Rust code to refer to fields,
etc. The source for these latter constructs, however, is not surfaced in the
project. You just import them where needed.

The import statements look like:

```
use crate::db::schema::lists::dsl::*
```

where the schema.rs file is located in 'src/db/', and includes a generated 'lists'
table structure.

Given this machiery, the DAO code can use familiar collection terminology like
'filter', etc. for manipulating tables, by using the table name, e.g., 'lists', 
as pseudo-collections, and using the above model data structures to repesent 
data queried (Queryable) or inserted (Insertable).

### Getting Started Links

```
https://diesel.rs/guides/getting-started/
https://github.com/diesel-rs/diesel/blob/1.4.x/examples/sqlite/getting_started_step_3/
http://diesel.rs/guides/schema-in-depth/
```

An independent (but a bit outdated) guide for sqlite:

https://medium.com/@fdeantoni/rust-actix-diesel-sqlite-d67a1c3ef0e

### Steps

- install-diesel-cli.sh

In installing the diesel cli, I had to specify just the databases I needed to be
supported. If one of the default supported databases is not installed, the
build will fail. It needs the client libraries of all the databases to be
supported.

```
https://crates.io/crates/diesel_cli
```

- Create a module called db: models, schema, and listdao.

  schema.rs is generated by diesel.

- Create an .env file at root incluing `DATABASE_URL="database/lists.db"`.

- `diesel-setup.sh`

Creates the database and adds a migration table to it. Creates an empty
migration folder, and generates the a file called diesel.toml. The latter will
include the *default* location of the schema.rs file. However, ours is not at
the default location. It is under src/rocketeer/db. 

So edit diesel.toml and fix the location of the schema file.

- `setup-migration.sh listserver`

Creates empty up.sql and down.sql files `migration/<timestap>_listserver`.
The parameter is just an arbitrary name.

- Edit up.sql to include create statements, and down.sql to include drop
  statements. 

Use plural table names as the convention of table names being plurals of model
structure names is built into the code generation machinery of diesel.

Make sure you have a "not null primary key" field in the table. Both "not null"
and "primary key" are necessary for correct code generation.

- run-migration.sh 

Executes up.sql if not already executed. Generates or regenerates the 
schema.rs file.

- In models.rs create two structs parallel to each table - one Queryable and one
  Insertable. Naming convention for queryable is sigular matching the table name
  (different table name cannot be specified for it). Naming convention for
  Insertable is arbitrary - since the table name can be specified for it.

It seems redundant to use a different struct for insertions. You cannot use the
same struct, and that is by design, likely to make it easy to deal with
auto-increment, defaults, etc. 


    https://stackoverflow.com/questions/47375895/understanding-trait-bound-error-in-diesel
    
    https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters

- There is a generic Connection trait that all connection types implement. 
  I had hoped therefore to use the trait is my DAO code. But I ran out of time
  trying to do that. Connection has type parameters, and I was unable to 
  set those up correctly for a generic connection.


